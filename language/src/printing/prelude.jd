
type ToStr<T> = {
    str: (T) => string
}

type ToFloat<T> = {
    float: (T) => float
}

type ToInt<T> = {
    int: (T) => int
}

const IntToStr: ToStr<int> = ToStr<int>{str: intToString}
const FloatToStr: ToStr<float> = ToStr<float>{str: floatToString}
const IntToFloat: ToFloat<int> = ToFloat<int>{float: intToFloat}
const FloatToInt: ToInt<float> = ToInt<float>{int: floatToInt}

// x as float
// IntAs<float>(x)
// type As<From, To> = {
//     as: (From) => To,
// }
const IntAsFloat = As<int, float>{as: intToFloat}
const FloatAsInt = As<float, int>{as: floatToInt}
const IntAsString = As<int, string>{as: intToString}
const FloatAsString = As<float, string>{as: floatToString}

// Equality and stuff
type Eq<T> = {
    "==": (T, T) => bool,
}

@glsl_builtin
const IntEq = Eq<int>{"==": intEq}
@glsl_builtin
const FloatEq = Eq<float>{"==": floatEq}
@glsl_builtin
const StringEq = Eq<string>{"==": stringEq}

// For checking equality

const rec arrayEq: <T,>(Array<T>, Array<T>, Eq<T>) => bool
 = <T,>(one: Array<T>, two: Array<T>, eq: Eq<T>): bool => {
    switch (one, two) {
        ([], []) => true,
        ([one, ...rone], [two, ...rtwo]) => if eq."=="(one, two) {
            arrayEq<T>(rone, rtwo, eq)
        } else {
            false
        },
        _ => false
    }
}

const ArrayEq = <T,>(eq: Eq<T>) => Eq<Array<T>>{
    "==": (one: Array<T>, two: Array<T>) => 
    len<T>(one) == len<T>(two) && arrayEq<T>(one, two, eq)
}
const ArrayStringEq = ArrayEq<string>(StringEq)
const ArrayIntEq = ArrayEq<int>(IntEq)
const ArrayFloatEq = ArrayEq<float>(FloatEq)


//// ------ GLSL -------

@ffi
type Vec2 = {
    x: float,
    y: float
}

@ffi
type Vec3 = {
    ...Vec2,
    z: float
}

@ffi
type Vec4 = {
    ...Vec3,
    w: float,
}

@ffi
type Mat4 = {
    r1: Vec4,
    r2: Vec4,
    r3: Vec4,
    r4: Vec4,
}

@unique(0.0)
type AddSub<A, B, C> = {
    "+": (A, B) => C,
    "-": (A, B) => C
}

@unique(1.0)
type Mul<A, B, C> = {
    "*": (A, B) => C
}

@unique(2.0)
type Div<A, B, C> = {
    "/": (A, B) => C
}

@unique(3.0)
type Neg<A, B> = {
    "-": (A) => B
}

@unique(3.0)
type Ord<A, B> = {
    "<": (A, B) => bool,
    ">": (A, B) => bool,
    "<=": (A, B) => bool,
    ">=": (A, B) => bool,
}

const Vec2Ord = Ord<Vec2, Vec2>{
    "<": (a: Vec2, b: Vec2) => a.x < b.x && a.y < b.y,
    ">": (a: Vec2, b: Vec2) => a.x > b.x && a.y > b.y,
    "<=": (a: Vec2, b: Vec2) => a.x <= b.x && a.y <= b.y,
    ">=": (a: Vec2, b: Vec2) => a.x >= b.x && a.y >= b.y,
}

@glsl_builtin
const AddSubVec4 = AddSub<Vec4, Vec4, Vec4>{
    "+": (one: Vec4, two: Vec4) => Vec4{x: one.x + two.x, y: one.y + two.y, z: one.z + two.z, w: one.w + two.w},
    "-": (one: Vec4, two: Vec4) => Vec4{x: one.x - two.x, y: one.y - two.y, z: one.z - two.z, w: one.w - two.w},
}

@glsl_builtin
const AddSubVec3 = AddSub<Vec3, Vec3, Vec3>{
    "+": (one: Vec3, two: Vec3) => Vec3{x: one.x + two.x, y: one.y + two.y, z: one.z + two.z},
    "-": (one: Vec3, two: Vec3) => Vec3{x: one.x - two.x, y: one.y - two.y, z: one.z - two.z},
}

@glsl_builtin
const AddSubVec2 = AddSub<Vec2, Vec2, Vec2>{
    "+": (one: Vec2, two: Vec2) => Vec2{x: one.x + two.x, y: one.y + two.y},
    "-": (one: Vec2, two: Vec2) => Vec2{x: one.x - two.x, y: one.y - two.y},
}

@glsl_builtin
const AddSubVec2_ = AddSub<Vec2, float, Vec2>{
    "+": (one: Vec2, two: float) => Vec2{x: one.x + two, y: one.y + two},
    "-": (one: Vec2, two: float) => Vec2{x: one.x - two, y: one.y - two},
}

@glsl_builtin
const AddSubVec3_ = AddSub<Vec3, float, Vec3>{
    "+": (one: Vec3, two: float) => Vec3{x: one.x + two, y: one.y + two, z: one.z + two},
    "-": (one: Vec3, two: float) => Vec3{x: one.x - two, y: one.y - two, z: one.z - two},
}

@glsl_builtin
const MulVec3 = Mul<Vec3, Vec3, Vec3>{
    "*": (one: Vec3, two: Vec3) => Vec3{x: one.x * two.x, y: one.y * two.y, z: one.z * two.z},
}

@glsl_builtin
const ScaleVec4_ = Mul<Vec4, float, Vec4>{
    "*": (v: Vec4, scale: float) => Vec4{x: v.x * scale, y: v.y * scale, z: v.z * scale, w: v.w * scale}
}

@glsl_builtin
const ScaleVec3_ = Mul<Vec3, float, Vec3>{
    "*": (v: Vec3, scale: float) => Vec3{x: v.x * scale, y: v.y * scale, z: v.z * scale}
}

@glsl_builtin
const ScaleVec3 = Mul<float, Vec3, Vec3>{
    "*": (scale: float, v: Vec3) => Vec3{x: v.x * scale, y: v.y * scale, z: v.z * scale}
}

@glsl_builtin
const Scale4 = Div<Vec4, float, Vec4>{
    "/": (v: Vec4, scale: float) => Vec4{x: v.x / scale, y: v.y / scale, z: v.z / scale, w: v.w / scale}
}

@glsl_builtin
const Scale42 = Div<Vec4, Vec4, Vec4>{
    "/": (v: Vec4, scale: Vec4) => Vec4{x: v.x / scale.x, y: v.y / scale.y, z: v.z / scale.z, w: v.w / scale.w}
}

@glsl_builtin
const Mul42 = Mul<Vec4, Vec4, Vec4>{
    "*": (v: Vec4, scale: Vec4) => Vec4{x: v.x * scale.x, y: v.y * scale.y, z: v.z * scale.z, w: v.w * scale.w}
}

@glsl_builtin
const MulVec2 = Div<Vec2, Vec2, Vec2>{
    "/": (v: Vec2, scale: Vec2) => Vec2{x: v.x / scale.x, y: v.y / scale.y}
}

@glsl_builtin
const ScaleVec2 = Mul<Vec2, Vec2, Vec2>{
    "*": (v: Vec2, scale: Vec2) => Vec2{x: v.x * scale.x, y: v.y * scale.y}
}

@glsl_builtin
const ScaleVec3Rev = Div<Vec3, float, Vec3>{
    "/": (v: Vec3, scale: float) => Vec3{x: v.x / scale, y: v.y / scale, z: v.z / scale}
}

@glsl_builtin
const Vec2float = Mul<Vec2, float, Vec2>{
    "*": (v: Vec2, scale: float) => Vec2{x: v.x * scale, y: v.y * scale}
}

@glsl_builtin
const ScaleVec2Rev = Div<Vec2, float, Vec2>{
    "/": (v: Vec2, scale: float) => Vec2{x: v.x / scale, y: v.y / scale}
}

// Ugh I need a "just add", and not sure how to distinguish
// between something else.
// Do I need to make the jump to 'multiple names' now?
// I mean I think I probably do.
// Ok, so we want "type-directed name resolution", right?
// I also want rather more inference of like function types and stuff.

// So yeah, names added in order of creation, so most recently added one
// will be the "first choice", but if it misses, then go on to other ones.

@glsl_builtin
const NegVec3 = Neg<Vec3, Vec3>{
    "-": (v: Vec3) => Vec3{x: -v.x, y: -v.y, z: -v.z},
}

@glsl_builtin
const length = (v: Vec2) => sqrt(v.x * v.x + v.y * v.y)
@glsl_builtin
const length = (v: Vec3) => sqrt(v.x * v.x + v.y * v.y + v.z * v.z)

@glsl_builtin
const radians = (degrees: float) => degrees / 180.0 * PI

@glsl_builtin
const normalize = (v: Vec3) => v / length(v)

@glsl_builtin
const vec2 = (x: float) => Vec2{x: x, y: x}
@glsl_builtin
const vec2 = (x: float, y: float) => Vec2{x: x, y: y}
@glsl_builtin
const vec3 = (x: float) => Vec3{x: x, y: x, z: x}
@glsl_builtin
const vec3 = (x: float, y: float, z: float) => Vec3{x: x, y: y, z: z}
@glsl_builtin
const vec3 = (v: Vec2, z: float) => Vec3{...v, z: z}
@glsl_builtin
const vec4 = (x: float) => Vec4{x: x, y: x, z: x, w: x}
@glsl_builtin
const vec4 = (x: float, y: float, z: float, w: float) => Vec4{x: x, y: y, z: z, w: w}
@glsl_builtin
const vec4 = (v: Vec2, z: float, w: float) => Vec4{...v, z: z, w: w}
@glsl_builtin
const vec4 = (v: Vec3, w: float) => Vec4{...v, w: w}

@glsl_builtin
const dot = (a: Vec3, b: Vec3) => {
    a.x * b.x + a.y * b.y + a.z * b.z
}
@glsl_builtin
const dot = (a: Vec2, b: Vec2) => {
    a.x * b.x + a.y * b.y
}
@glsl_builtin
const dot = (a: Vec4, b: Vec4) => {
    a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

@glsl_builtin
const reflect = (I: Vec3, N: Vec3) => {
    I - 2.0 * dot(N, I) * N
}

@glsl_builtin
const distance = (one: Vec3, two: Vec3) => length(two - one)
@glsl_builtin
const distance = (one: Vec2, two: Vec2) => length(two - one)

const MatByVector = Mul<Mat4, Vec4, Vec4>{
    "*": (mat: Mat4, vec: Vec4) => Vec4{
        x: dot(mat.r1, vec),
        y: dot(mat.r2, vec),
        z: dot(mat.r3, vec),
        w: dot(mat.r4, vec)
    }
}

const xyz = (v: Vec4) => Vec3{x: v.x, y: v.y, z: v.z}

@glsl_builtin
const clamp = (v: float, minv: float, maxv: float) => max(min(v, maxv), minv)

@glsl_builtin
const clamp = (v: Vec3, min: Vec3, max: Vec3) => Vec3{
    x: clamp(v.x, min.x, max.x),
    y: clamp(v.y, min.y, max.y),
    z: clamp(v.z, min.z, max.z),
}

@glsl_builtin
const max = (v: Vec2, n: float) => Vec2{
    x: max(v.x, n),
    y: max(v.y, n),
}

@glsl_builtin
const round = (v: Vec2) => Vec2{
    x: round(v.x),
    y: round(v.y),
}

@glsl_builtin
const round = (v: Vec3) => Vec3{
    x: round(v.x),
    y: round(v.y),
    z: round(v.z),
}

// END GLSL PRELUDE


// Ok, so now what I want to do
// is make a bunch of circles
// and, like,
// do I need an array for that?
// Can I turn an array reduce into ...
// something?
// Should I have a builtin "range"?
// And then "reduce" + "range" just becomes a for loop accumulator?
// That sounds reasonable.

const sminCubic = ( a: float, b: float, k: float ) =>
{
    const h = max( k - abs(a - b), 0.0 ) / k;
    const sixth = 1.0 / 6.0;
    min( a, b ) - h * h * h * k * sixth;
}

const opRepLim = ( p: Vec3, c: float, l: Vec3) => {
    p - c * clamp(round(p / c), -l, l);
}

@glsl_builtin
const fract = (v: float) => v - floor(v)
@glsl_builtin
const fract = (v: Vec3) => Vec3{x: fract(v.x), y: fract(v.y), z: fract(v.z)}
const abs3 = (v: Vec3) => Vec3{x: abs(v.x), y: abs(v.y), z: abs(v.z)}

const random = (st: Vec2) => {
    fract(sin(dot(st, Vec2{x: 12.9898, y: 78.233})) * 43758.5453123);
}

const PHI = 1.61803398874989484820459  // Î¦ = Golden Ratio   

const random3 = (xy: Vec2, seed: float) => {
    fract(tan(distance(xy * PHI, xy) * seed) * xy.x);
}

// const random = (xy: Vec2) => {
//     fract(tan(distance(xy * PHI, xy) * 200.0) * xy.x);
// }

const max = (v: Vec2) => {
    max(v.x, v.y)
}

const max = (v: Vec3) => {
    max(max(v.x, v.y), v.z);
}

const random2 = (co: Vec2) => {
    const a = 12.9898;
    const b = 78.233;
    const c = 43758.5453;
    const dt = dot(co, Vec2{x: a,y: b});
    const sn = mod(dt, 3.14);
    fract(sin(sn) * c);
}

// START HERE: need to resolve ambiguity between
// [self] and a [term]
@glsl_builtin
const abs = (v: Vec3) => Vec3{x: abs(v.x), y: abs(v.y), z: abs(v.z)}
@glsl_builtin
const abs = (v: Vec2) => Vec2{x: abs(v.x), y: abs(v.y)}

const box = (samplePoint: Vec3, pos: Vec3, dims: Vec3) => {
    max(abs(samplePoint - pos) - dims)
}

const lerp = (a: float, b: float, c: float) => c * (b - a) + a

@glsl_builtin
const mix = (a: Vec2, b: Vec2, c: float) => {
    Vec2{x: lerp(a.x, b.x, c), y: lerp(a.y, b.y, c)}
}

@glsl_builtin
const mix = (a: Vec3, b: Vec3, c: float) => {
    Vec3{x: lerp(a.x, b.x, c), y: lerp(a.y, b.y, c), z: lerp(a.z, b.z, c)}
}

@glsl_builtin
const mix = (a: Vec4, b: Vec4, c: float) => {
    Vec4{x: lerp(a.x, b.x, c), y: lerp(a.y, b.y, c), z: lerp(a.z, b.z, c), w: lerp(a.w, b.w, c)}
}

@glsl_builtin
const smoothstep = (edge0: float, edge1: float, x: float) => {
    const t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    t * t * (3.0 - 2.0 * t);
}

@ffi
type GLSLEnv = {
    time: float,
    resolution: Vec2,
    camera: Vec3,
    mouse: Vec2,
}

@ffi
type GLSLBuffer1 = {
    fragment: (GLSLEnv, Vec2, sampler2D) => Vec4,
    buffer0: (GLSLEnv, Vec2, sampler2D) => Vec4,
}

@ffi
type GLSLEnv<T> = {
    state: T,
    time: float,
    resolution: Vec2,
    camera: Vec3,
    mouse: Vec2,
    mouseButton: int,
}

@ffi
type GLSLScene<T> = {
    initial: T,
    step: (GLSLEnv<T,>, GLSLEnv<T,>) => T,
    render: (GLSLEnv<T>, Vec2) => Vec4,
}

// GLSL Tests you see

// type ResultsState = {
//     passed: float,
//     failed: float,
//     idx: int,
// }
// const rows = 20
// const showGlslTestResults = <N: int,>(env: GLSLEnv, fragCoord: Vec2, results: FixedArray<N, bool>) => {
//     const size = env.resolution.x / (rows as float);
//     const state = reduce(results, ResultsState{passed: 100.0, failed: 100.0, idx: 0}, (state: ResultsState, passed: bool) => {
//         const col = modInt(state.idx, rows);
//         const row = (state.idx / rows) as int;
//         const pos = Vec2{x: col * size, y: row * size};
//         const circle = length(fragCoord - pos) - size / 2.0;
//         if passed {
//             ResultsState{
//                 ...state,
//                 passed: min(state.passed, circle),
//                 idx: state.idx + 1,
//             }
//         } else {
//             ResultsState{
//                 ...state,
//                 failed: min(state.failed, circle),
//                 idx: state.idx + 1,
//             }
//         }
//     });
//     if state.passed < 0.0 {
//         Vec4{x: 0.0, y: 1.0, z: 0.0, w: 1.0}
//     } else if state.failed < 0.0 {
//         Vec4{x: 0.0, y: 1.0, z: 0.0, w: 1.0}
//     } else {
//         Vec4{x: 1.0, y: 1.0, z: 1.0, w: 1.0}
//     }
// }
// const testCircle = (passed: bool,)
