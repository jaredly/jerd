import fs from 'fs';
import { typeDefToGo, Env, idToGo } from '../printing/goPrinter';
import { loadInit } from '../printing/loadPrelude';
import { atom, PP, printToString } from '../printing/printer';
import * as pp from '../printing/printer';
import { newWithGlobal } from '../typing/types';
import {
    allTypeIdsRaw,
    idName,
    nameForId,
    typeForId,
    typeForIdRaw,
} from '../typing/env';
import { OutputOptions } from '../printing/glslPrinter';
import { OutputOptions as IOutputOptions } from '../printing/ir/types';

export const typeDefsToGo = (
    env: Env,
    opts: OutputOptions,
    irOpts: IOutputOptions,
    ids: Array<string>,
): Array<PP | null> => {
    return ids
        .map((idRaw) => typeDefToGo(env, opts, irOpts, idRaw))
        .concat(typeAliasesToGo(env, opts, irOpts, ids));
};

export const typeAliasesToGo = (
    env: Env,
    opts: OutputOptions,
    irOpts: IOutputOptions,
    ids: Array<string>,
): Array<PP | null> => {
    return ([] as Array<PP | null>).concat(
        ...Object.keys(env.global.typeNames).map((name) =>
            env.global.typeNames[name].map((id, i) =>
                !ids.includes(idName(id)) || typeForId(env, id).typeVbls.length
                    ? null
                    : pp.items([
                          atom(`type ${name}${i > 0 ? '_' + i : ''}`),
                          atom(' = '),
                          idToGo(env, opts, id, true),
                          atom(';'),
                      ]),
            ),
        ),
    );
};

export const enumAliasesToGo = (env: Env, ids: Array<string>) => {
    const items: Array<PP> = [];
    ids.forEach((idRaw) => {
        const name = nameForId(env, idRaw) || `T${idRaw}`;
        const defn = typeForIdRaw(env, idRaw);
        // if (!defn) {
        //     throw new Error(`No enum ${idRaw}`)
        // }
        // UMM: Why would it not be defined?
        if (defn && defn.type === 'Enum') {
            defn.items.forEach((t, idx) => {
                const subName =
                    nameForId(env, idName(t.ref.id)) || `T${idName(t.ref.id)}`;
                items.push(
                    pp.items([
                        atom(`const `),
                        atom(`${name}_${subName}`),
                        atom(' int = '),
                        atom(idx.toString()),
                        atom(';'),
                    ]),
                );
            });
        }
    });

    return items;
};

export function generateGoTypes(input: string, output: string) {
    const init = loadInit(input ? fs.readFileSync(input, 'utf8') : undefined);
    const env: Env = {
        ...newWithGlobal(init.initialEnv),
        typeDefs: {},
        usedImports: {},
    };
    const items = typeDefsToGo(env, {}, {}, allTypeIdsRaw(env));
    items.push(...enumAliasesToGo(env, allTypeIdsRaw(env)));

    const code = items
        .map((pp) => (pp ? printToString(pp, 100) : ''))
        .join('\n\n');
    const preamble = `package main\n// AUTOGENERATED by 'node bootstrap.js go-types'\n`;
    fs.writeFileSync(output, preamble + code, 'utf8');
}
