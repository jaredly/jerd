
@ffi
type Vec2 = {
    x: float,
    y: float
}

@ffi
type Vec3 = {
    ...Vec2,
    z: float
}

@ffi
type Vec4 = {
    ...Vec3,
    w: float,
}

@ffi
type Mat4 = {
    r1: Vec4,
    r2: Vec4,
    r3: Vec4,
    r4: Vec4,
}

@unique(0.0)
type AddSub<A> = {
    "+": (A, A) => A,
    "-": (A, A) => A
}

@unique(1.0)
type Mul<A, B, C> = {
    "*": (A, B) => C
}

@unique(2.0)
type Div<A, B, C> = {
    "/": (A, B) => C
}

const AddSubVec4 = AddSub<Vec4>{
    "+": (one: Vec4, two: Vec4) => Vec4{x: one.x + two.x, y: one.y + two.y, z: one.z + two.z, w: one.w + two.w},
    "-": (one: Vec4, two: Vec4) => Vec4{x: one.x - two.x, y: one.y - two.y, z: one.z - two.z, w: one.w - two.w},
}

const AddSubVec3 = AddSub<Vec3>{
    "+": (one: Vec3, two: Vec3) => Vec3{x: one.x + two.x, y: one.y + two.y, z: one.z + two.z},
    "-": (one: Vec3, two: Vec3) => Vec3{x: one.x - two.x, y: one.y - two.y, z: one.z - two.z},
}

const AddSubVec2 = AddSub<Vec2>{
    "+": (one: Vec2, two: Vec2) => Vec2{x: one.x + two.x, y: one.y + two.y},
    "-": (one: Vec2, two: Vec2) => Vec2{x: one.x - two.x, y: one.y - two.y},
}

const MulVec3 = Mul<Vec3, Vec3, Vec3>{
    "*": (one: Vec3, two: Vec3) => Vec3{x: one.x * two.x, y: one.y * two.y, z: one.z * two.z},
}

const ScaleVec3_ = Mul<Vec3, float, Vec3>{
    "*": (v: Vec3, scale: float) => Vec3{x: v.x * scale, y: v.y * scale, z: v.z * scale}
}

const ScaleVec3 = Mul<float, Vec3, Vec3>{
    "*": (scale: float, v: Vec3) => Vec3{x: v.x * scale, y: v.y * scale, z: v.z * scale}
}

const Scale4 = Div<Vec4, float, Vec4>{
    "/": (v: Vec4, scale: float) => Vec4{x: v.x / scale, y: v.y / scale, z: v.z / scale, w: v.w / scale}
}

const MulVec2 = Div<Vec2, Vec2, Vec2>{
    "/": (v: Vec2, scale: Vec2) => Vec2{x: v.x / scale.x, y: v.y / scale.y}
}

const ScaleVec3Rev = Div<Vec3, float, Vec3>{
    "/": (v: Vec3, scale: float) => Vec3{x: v.x / scale, y: v.y / scale, z: v.z / scale}
}

const Vec2float = Mul<Vec2, float, Vec2>{
    "*": (v: Vec2, scale: float) => Vec2{x: v.x * scale, y: v.y * scale}
}

const ScaleVec2Rev = Div<Vec2, float, Vec2>{
    "/": (v: Vec2, scale: float) => Vec2{x: v.x / scale, y: v.y / scale}
}

const negVec3 = (v: Vec3) => {
    Vec3{x: -v.x, y: -v.y, z: -v.z}
}

const length2 = (v: Vec2) => {
    sqrt(v.x * v.x + v.y * v.y)
}
const length = (v: Vec3) => {
    sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
}

const radians = (degrees: float) => degrees / 180.0 * PI

const normalize = (v: Vec3) => v / length(v)

const vec3 = (v: Vec2, z: float) => Vec3{...v, z: z}

const dot = (a: Vec3, b: Vec3) => {
    a.x * b.x + a.y * b.y + a.z * b.z
}

const dot2 = (a: Vec2, b: Vec2) => {
    a.x * b.x + a.y * b.y
}

const dot4 = (a: Vec4, b: Vec4) => {
    a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

const reflect = (I: Vec3, N: Vec3) => {
    I - 2.0 * dot(N, I) * N
}

const distance = (one: Vec3, two: Vec3) => length(two - one)
const distance2 = (one: Vec2, two: Vec2) => length2(two - one)

const vec4 = (x: float, y: float ,z: float, w: float) => Vec4{x:x, y:y, z:z, w:w}

const MatByVector = Mul<Mat4, Vec4, Vec4>{
    "*": (mat: Mat4, vec: Vec4) => Vec4{
        x: dot4(mat.r1, vec),
        y: dot4(mat.r2, vec),
        z: dot4(mat.r3, vec),
        w: dot4(mat.r4, vec)
    }
}

const xyz = (v: Vec4) => Vec3{x: v.x, y: v.y, z: v.z}

const clampF = (v: float, minv: float, maxv: float) => max(min(v, maxv), minv)

const clamp = (v: Vec3, min: Vec3, max: Vec3) => Vec3{
    x: clampF(v.x, min.x, max.x),
    y: clampF(v.y, min.y, max.y),
    z: clampF(v.z, min.z, max.z),
}

const roundv2 = (v: Vec2) => Vec2{
    x: round(v.x),
    y: round(v.y),
}

const roundv = (v: Vec3) => Vec3{
    x: round(v.x),
    y: round(v.y),
    z: round(v.z),
}

// END GLSL PRELUDE

const MAX_MARCHING_STEPS = 255
const MIN_DIST = 0.0
const MAX_DIST = 100.0
const EPSILON = 0.00005


const sceneSDF = (iTime: float, samplePoint: Vec3) => {
    const double = iTime * 2.0;
    const p1 = samplePoint;
    length(p1) - 0.5
}

const shortestDistanceToSurface:
(float, Vec3, Vec3, float, float, int) => float
    = (
        iTime: float,
        // marchSource
        eye: Vec3,
        // marchDirection
        marchingDirection: Vec3,
        start: float,
        end: float,
        stepsLeft: int,
    ) => {
    if stepsLeft <= 0 {
        end
    } else {
        const dist = sceneSDF(iTime, eye + start * marchingDirection);
        if dist < EPSILON {
            start
        } else {
            const depth = start + dist;
            if depth >= end {
                end
            } else {
                shortestDistanceToSurface(iTime, eye, marchingDirection, depth, end, stepsLeft - 1)
            }
        }
    }
}


const rayDirection = (fieldOfView: float, size: Vec2, fragCoord: Vec2) => {
    const xy = fragCoord - size / 2.0;
    const z = size.y / tan(radians(fieldOfView) / 2.0);
    normalize(vec3(xy, -z))
}

@ffi
@main
const fishingBoueys = (iTime: float, fragCoord: Vec2, iResolution: Vec2) => {
    // The direction to march in from the eye position
    // which will then find the color of the provided pixel
	const dir = rayDirection(45.0, iResolution, fragCoord);
    const eye = Vec3{x: 0.0, y: 0.0, z: 5.0};
    const dist = shortestDistanceToSurface(iTime, eye, dir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS);

    if dist > MAX_DIST - EPSILON {
        // Nothing visible
        Vec4{x: 0.0, y: 0.0, z: 0.0, w: 1.0};
    } else {
        Vec4{x: 1.0, y: 0.0, z: 0.0, w: 1.0}
    }
}