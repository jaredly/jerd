
const estimateNormal = (sceneSDF: (Vec3) ={}> float): Vec3 ={}> vec3(sceneSDF(vec3(0.0)))

const callIt = (
    sceneSDF: (Vec3) ={}> float,
    eye: Vec3,
): float ={}> {
    sceneSDF(eye);
}

const marchNormals = (sceneSDF: (Vec3) ={}> float) ={}> (coord: Vec2) ={}> {
    const dist = callIt(sceneSDF, vec3(0.0));
    vec4(estimateNormal(sceneSDF), w: dist);
}

const superSample = (sdf: (Vec2) ={}> Vec4) ={}> (coord: Vec2) ={}> {
    sdf(coord)
}

@main
const unnamed = superSample(
    sdf: marchNormals(
        sceneSDF: (pos: Vec3): float ={}> length(
                v: pos,
            ) 
    ),
)


/* Ok, so at a basic level:

What I want is:
- calling a function that returns a function ... should
  make a wrapping function with the same args, and then
  inline the function call. Right?
- and then, relatedly, we specialize any function arguments
  that are lambdas.

*/