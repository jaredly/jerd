
effect Log {
    log: (string) => void,
}

// Start with the basic
const collectNew: (() ={Log}> void) ={}> string = 
(fn: () ={Log}> void): string => {
    handle! fn {
        Log.log((v) => k) => {
            v ++ "\n" ++ collectNew(() ={Log}> k())
        },
        pure(a) => "end"
    }
}

collectNew(() => {
    raise!(Log.log("Hello"));
    raise!(Log.log("Folks"));
}) == "Hello\nFolks\nend"

effect Read {
    read: () => string,
}

// Now for reading
const provide: <T>(string, () ={Read}> T) ={}> T = 
<T,>(v: string, fn: () ={Read}> T): T => {
    handle! fn {
        Read.read(() => k) => {
            provide<T>("<" + v + ">", () => k(v))
        },
        pure(a) => a
    }
}

provide<string,>("Hello", () => raise!(Read.read())) == "Hello"
// Multiple, lets do lets
provide<string,>("Hello", () => raise!(Read.read()) + raise!(Read.read())) == "Hello<Hello>"


// Start with the basic
const appendLog: (() ={Log}> string) ={}> string = 
(fn: () ={Log}> string): string => {
    handle! fn {
        Log.log((v) => k) => {
            v ++ "\n" ++ appendLog(() ={Log}> k())
        },
        pure(a) => a
    }
}

appendLog(() => {
    raise!(Log.log("Hello"));
    raise!(Log.log("Folks"));
    "Final value"
}) == "Hello\nFolks\nFinal value"


// Start with the basic
const collectPoly: {e}(() ={Log, e}> void) ={e}> string = 
{e}(fn: () ={Log, e}> void): string => {
    handle! fn {
        Log.log((v) => k) => {
            v ++ "\n" ++ collectPoly{e}(() ={Log, e}> k())
        },
        pure(a) => "end"
    }
}

collectPoly{}(() => raise!(Log.log("Good news"))) == "Good news\nend"

provide<string,>("Folks", () ={Read}> collectPoly{Read}(() ={Read, Log}> raise!(Log.log("Good news " + raise!(Read.read())))))
 == "Good news folks\nend"
