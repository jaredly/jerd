
type Some<T> = {
    value: T
}
type None = {}

enum Option<T> {
    Some<T>,
    None
}

// @typeError("found int, expected string")
Option<string>:Some<string>{_: "hi"}

type Nil = {}
type Cons<T, L> = {
    value: T,
    rest: L
}

enum LinkedList<T> {
    Nil,
    Cons<T, LinkedList<T>>,
}

type WithSelves = {
    name: string,
    selves: Array<WithSelves>,
}

const listToLinked: <T,>(Array<T>) => LinkedList<T>
 = <T,>(list: Array<T>): LinkedList<T> => {
    switch list {
        [] => LinkedList<T>:Nil,
        [one, ...rest] => LinkedList<T>:Cons<T, LinkedList<T>>{
            value: one,
            rest: listToLinked(rest),
        }
    }
} 

const linkedLength: <T>(LinkedList<T>) => int = <T,>(list: LinkedList<T>) => {
    switch list {
        Nil => 0,
        Cons{rest} => 1 + linkedLength<T>(rest)
    }
}

@typeError("same-typed arguments")
<T,>(list: LinkedList<T>) => {
    switch list {
        Nil => 0,
        Cons{rest} => 1 + rest
    }
}


linkedLength<int>(listToLinked<int>([3,4,5])) == 3

// enum Child#6db8c2b1<T#:0> {
//     String#54e44b4c,
//     T#:0,
// }

effect Timer {
    setTimeout: (() ={Timer}> void, int) => void,
}

// TODO try using it
const setTimeout = (fn: () ={Timer}> void, num: int) => raise!(Timer.setTimeout(fn, num))

setTimeout(() => setTimeout(() => {
log("Hello folks")
}, 100), 50)

