


effect Read {
    read: () => string,
}

effect Write {
    write: (string) => void,
}

const getString = () ={Read}> raise!(Read.read())

(a: int, b: string) ={Read, Write}> b + getString()

const both = () ={Read, Write}> {
    const value = raise!(Read.read());
    raise!(Write.write(value))
}
// Checking that this type checks and looks reasonable
both

// Ok now for the famous handlers!
const provideString: (string, () ={Read}> string) => string = (v: string, fn: () ={Read}> string) => handle! fn {
    Read.read(() => k) => provideString(v, () ={Read}> k(v + "got") + "back") + "provided",
    pure(v) => v + "pure"
}

provideString("Yes", getString) == "Yesgotbackpureprovided"

const provideStringPlain: (string, () ={Read}> string) => string = (v: string, fn: () ={Read}> string) => handle! fn {
    Read.read(() => k) => provideStringPlain(v, () ={Read}> k(v)),
    pure(v) => v,
}

const ifYes = () => if getString() == "Yes" {
    "good"
} else {
    "nope"
}

provideStringPlain("Yes", ifYes) == "good"
provideStringPlain("Yes?", ifYes) == "nope"


/*
const logWrite: {e}(() ={Write, e}> void) ={e}> void = {e}(fn: () ={Write, e}> void) => {
    handle! fn {
        Write.write((x) => k) => {
            log(x);
            logWrite{e}(() ={Write, e}> k())
        },
        pure(k) => k
    }
}

logWrite{}(() => raise!(Write.write("Hello")))

const respondWith: {e}(string, () ={Read, e}> void) ={e}> void = {e}(v: string, fn: () ={Read, e}> void) => {
    handle! fn {
        Read.read(() => k) => respondWith{e}(v, () ={Read, e}> k(v)),
        pure(x) => x,
    }
}

respondWith{}("Hello", () => logWrite{Read}(() => {
    const v = "Yes " ++ raise!(Read.read());
    raise!(Write.write(v))
}))
*/





/*
type Some<T> = {
    value: T
}
type None = {}

enum Option<T> {
    Some<T>,
    None
}

// @typeError("found int, expected string")
Option<string>:Some<string>{_: "hi"}

type Nil = {}
type Cons<T, L> = {
    value: T,
    rest: L
}

enum LinkedList<T> {
    Nil,
    Cons<T, LinkedList<T>>,
}

type WithSelves = {
    name: string,
    selves: Array<WithSelves>,
}

const listToLinked: <T,>(Array<T>) => LinkedList<T>
 = <T,>(list: Array<T>): LinkedList<T> => {
    switch list {
        [] => LinkedList<T>:Nil,
        [one, ...rest] => LinkedList<T>:Cons<T, LinkedList<T>>{
            value: one,
            rest: listToLinked(rest),
        }
    }
} 

const linkedLength: <T>(LinkedList<T>) => int = <T,>(list: LinkedList<T>) => {
    switch list {
        Nil => 0,
        Cons{rest} => 1 + linkedLength<T>(rest)
    }
}

@typeError("same-typed arguments")
<T,>(list: LinkedList<T>) => {
    switch list {
        Nil => 0,
        Cons{rest} => 1 + rest
    }
}


linkedLength<int>(listToLinked<int>([3,4,5])) == 3

// enum Child#6db8c2b1<T#:0> {
//     String#54e44b4c,
//     T#:0,
// }

*/