
effect Read {
    read: () => string,
}
effect Write {
    write: (string) => void,
}

// TODO once I have tuples
// const collect = <T,>(fn: () ={Stdio}> T): (string, T) => {
//     handle! fn {
//         Write.write((v) => k) => {
//             let (collected, a) = collect(v);
//             (collected ++ v, a)
//         }
//         pure(a) => ("", a)
//     }
// }

const tee = (x: string): string => {
    log("> " ++ x);
    x
}

const print = (x: string) ={Write}> raise!(Write.write(x))
const read = () ={Read}> raise!(Read.read())

const alwaysRead: <T,>{e}(string, () ={Read, e}> T) ={e}> T = <T,>{e}(value: string, fn: () ={Read, e}> T): T ={e}> {
    handle! fn {
        Read.read(() => k) => {
            // OOF ok this bit doesn't have the `directOrEffectful` set...
            // why not?
            // is it that the self isn't populating things right?
            alwaysRead<T>{e}(value, () => k(value))
        },
        pure(a) => a
    }
}

// This is so we can test the results
const collect: {e}(() ={Write, e}> void) ={e}> string = {e}(fn: () ={Write, e}> void): string => {
    handle! fn {
        Write.write((v) => k) => {
            v ++ "\n" ++ collect{e}(k)
        },
        pure(a) => "end"
    }
}

collect{}((): void => {
    raise!(Write.write("one"));
    raise!(Write.write("two"));
    raise!(Write.write("three"))
}) == "one\ntwo\nthree\nend"

collect{}((): void => {
    print("HI")
}) == "HI\nend"

collect{}((): void => {
    print("HI");
    print("HO");
}) == "HI\nHO\nend"

collect{}((): void => {
    raise!(Write.write("HI"));
    raise!(Write.write("HO"));
}) == "HI\nHO\nend"

// Working
collect{}(() => alwaysRead<void>{Write}("hi", () => print(raise!(Read.read()) ++ " and " ++ raise!(Read.read())) )) == "hi and hi\nend"

collect{}((): void => {
    print("A");
    print("B")
}) == "A\nB\nend"

collect{}(() => alwaysRead<void>{Write}("hi", () => {
    print(read());
    print("YA");
    print(read());
    print("B")
})) == "hi\nYA\nhi\nB\nend"


collect{}(() => alwaysRead<void>{Write}("hi", () => {
    raise!(Write.write("A"));
    const x = raise!(Read.read());
    raise!(Write.write("B"));
})) == "A\nB\nend"

collect{}(() => alwaysRead<void>{Write}("hi", () => {
    const x = raise!(Read.read());
    raise!(Write.write("B"));
})) == "B\nend"

// Here are the examples from the paper


const printFullName = () ={Read, Write}> {
    print("What is your forename?");
    const foreName = raise!(Read.read());
    print("What is your surname?");
    const surName = raise!(Read.read());
    print(foreName ++ " " ++ surName)
}

// Full first example from the eff paper
// # 2.1.1
collect{}((): void => {
    alwaysRead<void>{Write}("Me", printFullName)
}) == "What is your forename?\nWhat is your surname?\nMe Me\nend"

// This is so we can test the results
const reverse: (() ={Write}> void) ={Write}> void = (fn: () ={Write}> void): void ={Write}> {
    handle! fn {
        Write.write((v) => k) => {
            reverse(k);
            print(v)
        },
        pure(a) => a
    }
}

collect{}(() => reverse(() => {print("A"); print("B")})) == "B\nA\nend"

// # 2.1.2
collect{}((): void => {
    reverse(() => {
        alwaysRead<void>{Write}("Me", printFullName)
    })
}) == "Me Me\nWhat is your surname?\nWhat is your forename?\nend"


// # 2.3
effect Decide {
    decide: () => bool,
}
const decide = () ={Decide}> raise!(Decide.decide())

const choose: <T,>(T, T) ={Decide}> T = <T,>(x: T, y: T): T ={Decide}> {
    if decide() { x } else { y }
}
const pickTrue: <T,>(() ={Decide}> T) => T = <T,>(fn: () ={Decide}> T): T => handle! fn {
    Decide.decide(() => k) => pickTrue<T>(() => k(true)),
    pure(x) => x
}
const chooseDiff = () ={Decide}> {
    const x1 = choose(15, 30);
    const x2 = choose(5, 10);
    x1 - x2
}
pickTrue<int>(chooseDiff) == 10

// #2.3.1
const pickMax: (() ={Decide}> int) => int = (fn: () ={Decide}> int): int => handle! fn {
    Decide.decide(() => k) => {
        const xt = pickMax(() => k(true));
        const xf = pickMax(() => k(false));
        if xt > xf { xt } else { xf }
    },
    pure(x) => x
}
pickMax(chooseDiff) == 25

// #2.3.2
effect Fail {
    fail: () => int, // TODO this should really be an exit continuation...
}
const fail = () ={Fail}> raise!(Fail.fail())

const chooseInt: (int, int) ={Decide, Fail}> int = (m: int, n: int): int ={Decide, Fail}> {
    if m > n {
        fail();
        10
    } else {
        if decide() {
            m
        } else {
            chooseInt(m + 1, n)
        }
    }
}

const pythagorean = (m: int, n: int) ={Decide, Fail}> {
    const a = chooseInt(m, n - 1);
    const b = chooseInt(a + 1, n);
    const a2 = a * a;
    const b2 = b * b;
    if isSquare(a2 + b2) {
        intToString(a) ++ ":" ++ intToString(b)
    } else {
        fail();
        "??? how did this return"
    }
}

const handleFail = <T,>{e}(fn: () ={e, Fail}> T, orElse: () ={e}> T) ={e}> handle! fn {
    Fail.fail(() => _) => orElse(),
    pure(x) => x
}

// const handleFailPure = <T,>(fn: () ={Fail}> T, orElse: () ={}> T) ={}> handle! fn {
//     Fail.fail(() => _) => orElse(),
//     pure(x) => x
// }


const backtrack: <T,>(() ={Decide, Fail}> T) ={Fail}> T = <T,>(fn: () ={Decide, Fail}> T): T ={Fail}> {
    handle! fn {
        Decide.decide(() => k) => {
            backtrack(() => handleFail{Decide}(() => k(true), () => k(false)))
        },
        pure(x) => x
    }
}

const backtrackReverse: <T,>(() ={Decide, Fail}> T) ={Fail}> T = <T,>(fn: () ={Decide, Fail}> T): T ={Fail}> {
    handle! fn {
        Decide.decide(() => k) => {
            backtrackReverse(() => handleFail{Decide}(() => k(false), () => k(true)))
        },
        pure(x) => x
    }
}

const backtrackPythag = (m: int, n: int) => handleFail<string>{}(() => backtrack<string>(() => pythagorean(m, n)), () => "No solution found")

backtrackPythag(4, 15) == "5:12"
backtrackPythag(7, 10) == "No solution found"

const backtrackPythagReverse = (m: int, n: int) => handleFail<string>{}(() => backtrackReverse<string>(() => pythagorean(m, n)), () => "No solution found")
backtrackPythagReverse(4, 15) == "9:12"
10

// #2.4 State

effect Store {
    get: () => int,
    set: (int) => void,
}

const withInitialValue: <T,>(int, () ={Store}> T) => T = <T,>(value: int, fn: () ={Store}> T): T ={}> {
    handle! fn {
        Store.get(() => k) => withInitialValue(value, () => k(value)),
        Store.set((newValue) => k) => withInitialValue(newValue, k),
        pure(x) => x
    }
}

const getAndSet = () ={Store}> {
    const x = raise!(Store.get());
    raise!(Store.set(x + 4));
    intToString(x) ++ ":" ++ intToString(raise!(Store.get()))
}

withInitialValue<string>(10, getAndSet) == "10:14"

// # Effect variables! Got to have it.

const callPlus5 = {e}(x: () ={e}> int) ={e}> x() + 5

withInitialValue<int>(4, () ={Store}> callPlus5{Store}(() ={Store}> raise!(Store.get()))) == 9

callPlus5{}(() ={}> 4) == 9
