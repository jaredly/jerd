
const identity = <T,>(x: T): T => x
// lambda (x: var1) => var1
const get2 = identity<int>(2)

const callme = <T,>(x: (T) => T, arg: T): T => x(arg)

const addTwo = (one: int): int => one + 2

const callIt = callme<int>(addTwo, 5)

// Ok how's this for a unification algorithm:
// Construct a directed graph of type variables and constraints
// collapse / traverse the graph?
// hmm idk.
// anyway, first step is to do the no-inference version, right?




// const callOne = (f) => f(2, "hi")
// const test2 = () => callOne((a, b) => log(b))


